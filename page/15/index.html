<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 15 | 黎诗霆 | LI SHITING</title>

  
  <meta name="author" content="leo">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="黎诗霆"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="黎诗霆" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">黎诗霆</a>
    </h1>
    <p class="site-description">LI SHITING</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/tag">分类</a></li>
      
        <li><a href="/me">关于</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2016/04/20/How-to-use-Prolog/"><span>How to use Prolog</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/04/20/How-to-use-Prolog/" rel="bookmark">
        <time class="entry-date published" datetime="2016-04-20T08:39:00.000Z">
          2016-04-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="第一章-入门"><a href="#第一章-入门" class="headerlink" title="第一章 入门"></a>第一章 入门</h1><h3 id="1-hello-world："><a href="#1-hello-world：" class="headerlink" title="1. hello world："></a>1. hello world：</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">write(“<span class="symbol">Hello</span> <span class="symbol">World</span>”),nl,</div><div class="line">write(“<span class="symbol">Welcome</span> to <span class="symbol">Prolog</span>”),nl.</div></pre></td></tr></table></figure>
<p>以句号做结束，有一系列目标（goal）组成（一般也称为查询query），目标之间用,号隔开，这里的write和nl其实是内建的IO谓词，总共4个目标按顺序执行，nl是开始一个新行，所有目标达成，Prolog系统会输出yes。</p>
<h3 id="2-halt"><a href="#2-halt" class="headerlink" title="2. halt"></a>2. halt</h3><p>2、halt也是BIPs，用于结束Prolog系统，statistics用于系统统计（cpu、内存等）。BIPs都是会产生副作用的谓词。比如write就是会产生输出到用户屏幕副作用的IO谓词。</p>
<h3 id="3-第一个程序"><a href="#3-第一个程序" class="headerlink" title="3.第一个程序"></a>3.第一个程序</h3><p>写入下列代码并保存为prog1.pl:</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dog(fido).</div><div class="line">cat(felix).</div><div class="line">animal:-dog(<span class="symbol">X</span>).</div></pre></td></tr></table></figure>
<p>通过consult谓词，将该程序导入数据库（本质上，Prolog系统就是一个全局数据库）, 分析下代码：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dog(fido).</div><div class="line">cat(felix).</div></pre></td></tr></table></figure>
<p>就是所谓事实（fact），dog和cat就是谓词，而fido和felix是atom，这里陈述了两个事实：fido是一只狗，felix是一只猫：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">animal:-dog(<span class="symbol">X</span>).</div></pre></td></tr></table></figure>
<p>这句就是规则（rule），”:-“符号可以理解为如果(注：if)，X是变量，这里描述的规则就是：如果X是狗，那么X就是动物。因此，依据事实和规则，Prolog的推理系统可以推论：fido是狗，所以fido是动物：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">?- animal(fido).	</div><div class="line">yes</div></pre></td></tr></table></figure>
<p>显然，根据animal规则，felix不是动物，虽然它是：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">?- animal(felix).</div><div class="line">no</div></pre></td></tr></table></figure>
<h3 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h3><p>Prolog的注释</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* this is a comment */</span></div></pre></td></tr></table></figure>
<h3 id="5-查询"><a href="#5-查询" class="headerlink" title="5. 查询"></a>5. 查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dog(X)</div></pre></td></tr></table></figure>
<p>查询所有满足谓词dog的X，也就是找出所有的狗狗。<br>dog(X),cat(X).查询所有是狗又是猫的“东西”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Listing(dog)</div></pre></td></tr></table></figure>
<p>列出所有定义了谓词dog的语句。</p>
<h3 id="6-Prolog的数据类型"><a href="#6-Prolog的数据类型" class="headerlink" title="6. Prolog的数据类型"></a>6. Prolog的数据类型</h3><h4 id="1-数字-Number"><a href="#1-数字-Number" class="headerlink" title="1) 数字(Number)"></a>1) 数字(Number)</h4><p>623,+3,-.245</p>
<h4 id="2-原子-Atom"><a href="#2-原子-Atom" class="headerlink" title="2) 原子(Atom)"></a>2) 原子(Atom)</h4><p>所有的不包括数值在内的常量，包括：</p>
<ul>
<li>以小写字母开头的字母</li>
<li>数字</li>
<li>下划线的组合</li>
<li>单引号括起来的字符序列</li>
<li>+-*/&lt;&gt;=@&amp;#特殊字符组成的序列</li>
</ul>
<h4 id="3-变量-Variable"><a href="#3-变量-Variable" class="headerlink" title="3) 变量(Variable)"></a>3) 变量(Variable)</h4><p>在查询中代表未决的term，以<strong>大写字母</strong>或者<strong>下划线</strong>开头。<strong> _ 表示哑元</strong></p>
<h4 id="4-组合-Term"><a href="#4-组合-Term" class="headerlink" title="4) 组合(Term)"></a>4) 组合(Term)</h4><p>类似其他语言中的记录结构，以一个atom开头，后接一个参数列表，参数也都是term，<strong>参数的个数就是它的arity</strong>（Erlang也是如此），例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   read(X)</div><div class="line">dog(henry)</div><div class="line">likes(dog(henry),Y)</div></pre></td></tr></table></figure>
<h4 id="5-列表-Arrayr"><a href="#5-列表-Arrayr" class="headerlink" title="5) 列表(Arrayr)"></a>5) 列表(Arrayr)</h4><p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[dog,cat,mypred,[a,b,c],hello]</div></pre></td></tr></table></figure>
<h4 id="6-其它类型"><a href="#6-其它类型" class="headerlink" title="6) 其它类型"></a>6) 其它类型</h4><p>某些 Prolog方言可能会有字符串类型，用于处理字符串。</p>
<hr>
<h1 id="第二章-语句和谓词"><a href="#第二章-语句和谓词" class="headerlink" title="第二章 语句和谓词"></a>第二章 语句和谓词</h1><h3 id="1-Prolog程序"><a href="#1-Prolog程序" class="headerlink" title="1.Prolog程序"></a>1.Prolog程序</h3><p>一个Prolog程序就是由一系列语句（clause）组成的，语句可以多行，以引文句号结束。两种基础语句：<strong>事实和规则</strong>。</p>
<h3 id="2-事实语句"><a href="#2-事实语句" class="headerlink" title="2. 事实语句"></a>2. 事实语句</h3><p>是由atom或者组合term构成（两者统称为call terms），如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chrismas.</div><div class="line">likes(john,mary).</div></pre></td></tr></table></figure>
<h3 id="3-规则"><a href="#3-规则" class="headerlink" title="3. 规则"></a>3. 规则</h3><p>形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">head:-t1,t2,…,tk. (k&gt;=1)</div></pre></td></tr></table></figure>
<p>head成为规则的头部，也必须是call term，<strong>“:-“称为颈部操作符</strong>，<strong>读作if</strong>，而t1,t2…tk就是语句的body，它们描述了头部的结论所需要满足的条件。Body是由一个或者多个componet组成，compont就是目标，以逗号隔开，逗号表示and的关系。</p>
<p>从另一个角度看，head可以成为目标，body是它的子目标，规则就是为了达到目标head，必须先达到子目标t1,t2…tk。<br>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">large_animal(X):-</div><div class="line">animal(X),</div><div class="line">large(X).</div><div class="line"></div><div class="line">go:-</div><div class="line">write(‘hello world’),</div><div class="line">nl.</div></pre></td></tr></table></figure>
<h3 id="4-谓词"><a href="#4-谓词" class="headerlink" title="4. 谓词"></a>4. 谓词</h3><p>所有语句的头部都包括了一个谓词定义，不同参数的同名谓词是不同的谓词，参数数目就是所谓<strong>元数（arity）</strong>。</p>
<p>谓词可以记录为pred/n，比如parent/1,表示谓词名为parent,而参数个数是一个，这个与Erlang相同。谓词可分为用户自定义的维持和<strong>built-in谓词（BIPs）</strong>。IO谓词如write,nl就是BIPs，它们都是总会成功的谓词，并带来相应的IO副作用（输出和换行）。<strong>用户不能重定义BIPs</strong>。</p>
<h3 id="5-谓词的递归定义"><a href="#5-谓词的递归定义" class="headerlink" title="5.谓词的递归定义"></a>5.谓词的递归定义</h3><p>分为直接和间接递归，例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">likes(john,X):-likes(X,Y),dog(Y).</div></pre></td></tr></table></figure>
<p>描述的规则为:john喜欢的是那种至少喜欢一只狗的人。</p>
<h3 id="6-loading语句"><a href="#6-loading语句" class="headerlink" title="6. loading语句"></a>6. loading语句</h3><p>包括两个BIPs：consult/1和    reconsult/1，用于产生将文件中的语句导入数据库的副作用，两者的区别是，reconsult会覆盖之前定义的相同谓词，而consult不会。consult[‘prog1.pl’]可以简化为[‘prog1.pl’].同样，reconslt[‘prog1.pl’]可以简写为[-‘prog1.pl’]。</p>
<h3 id="7-变量"><a href="#7-变量" class="headerlink" title="7. 变量"></a>7. 变量</h3><p>一开始所有的变量都是未绑定的，当目标被执行时，变量可能被绑定或者解绑定。变量存在作用域，不同语句中的同名变量没有任何关系。</p>
<h3 id="8-量词，"><a href="#8-量词，" class="headerlink" title="8. 量词，"></a>8. 量词，</h3><h4 id="1）全称量词"><a href="#1）全称量词" class="headerlink" title="1）全称量词"></a>1）全称量词</h4><p>出现在事实或者规则head部分的变量，表示事实或者规则的该变量的所有可能值，这样的变量成为全称量词，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">large_animal(X):-animal(X),</div></pre></td></tr></table></figure>
<p>large(X). 中的X。</p>
<h4 id="2）存在量词"><a href="#2）存在量词" class="headerlink" title="2）存在量词"></a>2）存在量词</h4><p>不在事实或者规则的head部分中存在，但是在body部分中出现的量词，仅仅为了表示该变量至少存在一个值，这样的变量称为存在量词。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">person(dennis,zane,male,25,programmer).</div><div class="line">man(A):-person(A,B,male,C,D).</div></pre></td></tr></table></figure></p>
<p>man谓词body部分的B,C,D变量就是存在量词</p>
<h3 id="9-匿名变量"><a href="#9-匿名变量" class="headerlink" title="9. 匿名变量"></a>9. 匿名变量</h3><p>就是所谓哑元，下划线_表示，表示你并不care这个变量的值是什么，仅仅为了占位，用以表示任意值，与Erlang中的意义一致。</p>
<hr>
<h1 id="第三章-搜索目标的执行"><a href="#第三章-搜索目标的执行" class="headerlink" title="第三章 搜索目标的执行"></a>第三章 搜索目标的执行</h1><h3 id="1-执行目标"><a href="#1-执行目标" class="headerlink" title="1. 执行目标"></a>1. 执行目标</h3><p>Prolog系统是按照顺序执行目标的，每个目标都是由<strong>call term</strong>组成，每个目标都与一个相应的谓词相关联，<strong>谓词的名称称为functor</strong>，而参数个数就是元数（arity）。Prolog系统是<strong>从上到下</strong>，依据语句的head部分来匹配目标，如果匹配，将输出yes，否则就是no。对于用户定义的目标，Prolog没有找到任何事实或者规则与之匹配的话，那么就是fail。这不是什么未知或者不确定，这个其实就是所谓的<strong>封闭世界假设（closed world assumption）</strong>：任何结论如果无法从数据库中的事实和规则中得到证明，那么这个结论就是否定的，没有什么系统不确定或者未知这样的中间位置。</p>
<h3 id="2-联合（Unification）"><a href="#2-联合（Unification）" class="headerlink" title="2. 联合（Unification）"></a>2. 联合（Unification）</h3><p>变量可以跟任何term联合，其中包括了变量，其实就是变量的绑定。例如：X=1将X与1联合. dog(X)与dog(ferris)，将X与ferris联合。</p>
<ul>
<li><p>如果两个call term都是atom，只有当它们是一样的时候才可以联合，比如：</p>
<ul>
<li>test跟test联合成功</li>
<li>dennis跟’dennis’联合成功</li>
<li>apple跟fuck联合失败</li>
</ul>
</li>
<li><p>对于组合call term的联合，要求两个call term有一样的functor和arity，并且参数也要成对地联合成功。联合的详细规则如下：</p>
<ul>
<li>两个原子(atom): 当且仅当它们是<strong>一样</strong>的时候才是联合成功的。</li>
<li>两个组合的term: 当且仅当两者有<strong>一样的functor和airty</strong>，并且<strong>参数也要从左到右两两成对</strong>地联合成功。</li>
<li>两个number: 当且仅当它们是<strong>一样</strong>的时候，例如7与7联合成功，而7与6.9就失败</li>
<li>两个未绑定的变量: <strong>总是联合成功的</strong>，两者互相绑定</li>
<li>一个未绑定变量和一个不是变量的term也总是联合成功的，将变量绑定为该term</li>
<li>一个绑定的变量可以被认为它所绑定的值。例如: pred(X,X,man)与pred(landon,dog,A)联合失败，因为在第一个参数联合成功后，X就被认为是landon，那么在尝试联合第二个参数的时候，显然landon与dog联合失败。</li>
<li>两个列表联合成功，当且仅当它们拥有相同数目的元素，并且元素间从左到右成对地联合成功。</li>
<li><strong>嵌套结构</strong>按照这些规则递归，其他情况下的联合都是失败的。</li>
</ul>
</li>
</ul>
<h3 id="3-回溯-backtracking"><a href="#3-回溯-backtracking" class="headerlink" title="3.回溯(backtracking)"></a>3.回溯(backtracking)</h3><p>回溯就是一个返回前一个满足的目标，寻找其他方式重新满足该目标的过程。回溯，顾名思义就是退回去，再来过。<strong>当输入;号</strong>，就强制Prolog系统回溯以<strong>寻找更多的匹配</strong>。</p>
<hr>
<h1 id="第四章-操作符"><a href="#第四章-操作符" class="headerlink" title="第四章 操作符"></a>第四章 操作符</h1><h3 id="1-op谓词"><a href="#1-op谓词" class="headerlink" title="1.op谓词"></a>1.op谓词</h3><p>1、通过op谓词，可以将用户自定义的谓词转成某种操作符，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">likes(dennis,catty).</div></pre></td></tr></table></figure></p>
<p>我们更希望表达成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dennis likes catty.</div></pre></td></tr></table></figure></p>
<p>这在默认情况是不行的，通过op谓词转化likes谓词成中缀操作符,然后就可以这样使用likes谓词了：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">op(<span class="number">150</span>,xfy,likes).</div><div class="line">dennis likes catty.</div></pre></td></tr></table></figure></p>
<p>op谓词一般形式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">op(操作符优先级，(xfy|xf|fy),谓词名称)</div></pre></td></tr></table></figure></p>
<h3 id="2-算术运算"><a href="#2-算术运算" class="headerlink" title="2. 算术运算"></a>2. 算术运算</h3><p>通过内建的<strong>is/2</strong>谓词来进行算术运算，is/2是一个内建的<strong>中缀运算符</strong>，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">X is 2.</div><div class="line">X is 3,Y is X+3.</div></pre></td></tr></table></figure></p>
<p>出现在第二个参数的变量必须是已经绑定。<strong>+ - * /称为算术运算符</strong>，还有一类称为算术函数，它们并不是谓词，例如<strong>abs/1 sqrt/1</strong>等，完整列表：</p>
<ul>
<li>+ - * / 加减乘除</li>
<li>X//Y 两个整数的商</li>
<li>X^Y 表示X的Y次方，在gnu prolog上是**，与ruby一样。</li>
<li>-X 一元操作符</li>
<li>abs(X)</li>
<li>sqrt(X)</li>
<li>sin(X)</li>
<li>cos(X)</li>
<li>max(X,Y)</li>
</ul>
<p>is/2的第一个参数也可以是表达式或者数字，在此情况下，两个参数都会被计算，如果相等，则succeeds，否则失败。因此is/2谓词也可以解释为，求值看两个参数是否可以联合成功。如果第一个参数是变量，就将第二个参数的值绑定在该变量上，如果第一个参数是数值或者算术表达式，就比较两个参数的值是否相等，相等则联合成功，如果第一个参数是atom,term.list等，联合的情况依赖于实现。永远失败的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">is/2:X is X+1.</div></pre></td></tr></table></figure></p>
<h3 id="3-操作符"><a href="#3-操作符" class="headerlink" title="3. 操作符"></a>3. 操作符</h3><p>算术比较操作符：=:=,=\=,&gt;,&gt;=,&lt;,=&lt;</p>
<h4 id="1）算术表达式比较"><a href="#1）算术表达式比较" class="headerlink" title="1）算术表达式比较"></a>1）算术表达式比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">E1=:=E2 //成功当且仅当两个表达式求值的结果一致。</div><div class="line">E1=\=E2 //成功当且仅当两个表达式求值的结果不一致。</div></pre></td></tr></table></figure>
<h4 id="2）Term相同比较"><a href="#2）Term相同比较" class="headerlink" title="2）Term相同比较"></a>2）Term相同比较</h4><p>Term1==Term2成功当且仅当Trem1跟Term2完全相同。<br>因此：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">likes(X,prolog)==likes(X,prolog) //相同</div><div class="line">likes(Y,prolog)==likes(Y,prolog) //失败，X与Y是不同的变量</div><div class="line">3+7==6+4 //失败，两个表达式不会被求值，显然不同</div><div class="line">Term1 \==Term2 //成功当且仅当Trem1跟Term2不同</div></pre></td></tr></table></figure></p>
<h4 id="3）Term联合的比较"><a href="#3）Term联合的比较" class="headerlink" title="3）Term联合的比较"></a>3）Term联合的比较</h4><p>=操作符与==类似，不同在于，Term1=Term2当且仅当Term1和Term2联合成功的时候成功，也就是能找到某种方式绑定变量的值，来让两者相同。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">6+X=6+3.   //成功，X绑定为3</div><div class="line">6+4=3+7。  //仍然失败</div><div class="line">X=0,X=:=0. //成功，将X绑定为0，算术比较成功。</div></pre></td></tr></table></figure></p>
<p><strong>=的相反操作符就是\=</strong></p>
<h3 id="4-逻辑操作符"><a href="#4-逻辑操作符" class="headerlink" title="4.逻辑操作符"></a>4.逻辑操作符</h3><p>取反操作符not，表示or的;<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">X=0,not X is 0. //返回no</div><div class="line">6&lt;3;7 is 2+5.   //返回yes</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="第五章-循环"><a href="#第五章-循环" class="headerlink" title="第五章 循环"></a>第五章 循环</h1><h3 id="1-一定次数的循环"><a href="#1-一定次数的循环" class="headerlink" title="1. 一定次数的循环"></a>1. 一定次数的循环</h3><p>看代码，与Erlang一模一样：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">loop(<span class="number">0</span>).</div><div class="line">loop(<span class="symbol">N</span>):-</div><div class="line"><span class="symbol">N</span>&gt;<span class="number">0</span>,</div><div class="line">write(<span class="string">'The value is:'</span>),</div><div class="line">write(<span class="symbol">N</span>),</div><div class="line">nl,</div><div class="line"><span class="symbol">M</span> is <span class="symbol">N</span><span class="number">-1</span>,</div><div class="line">loop(<span class="symbol">M</span>).</div></pre></td></tr></table></figure></p>
<p>再看一个例子：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">output_values(<span class="symbol">Last</span>,<span class="symbol">Last</span>):- </div><div class="line">    write(<span class="symbol">Last</span>),</div><div class="line">    nl,</div><div class="line">    write(<span class="string">'end of example'</span>),</div><div class="line">    nl.</div><div class="line"></div><div class="line">output_values(<span class="symbol">First</span>,<span class="symbol">Last</span>):-</div><div class="line">       <span class="symbol">First</span>=\=<span class="symbol">Last</span>,</div><div class="line">    write(<span class="symbol">First</span>),</div><div class="line">    nl,</div><div class="line">    <span class="symbol">N</span> is <span class="symbol">First</span>+<span class="number">1</span>,</div><div class="line">    output_values(<span class="symbol">N</span>,<span class="symbol">Last</span>).</div></pre></td></tr></table></figure></p>
<h3 id="2-循环直到条件满足"><a href="#2-循环直到条件满足" class="headerlink" title="2. 循环直到条件满足"></a>2. 循环直到条件满足</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">go:-loop(start).</div><div class="line">    loop(end).</div><div class="line">    loop(<span class="symbol">X</span>):-</div><div class="line">        <span class="symbol">X</span>\=end,</div><div class="line">        write(<span class="string">'Type end to end'</span>),</div><div class="line">        read(<span class="symbol">Word</span>),</div><div class="line">        write(<span class="string">'Input was'</span>),</div><div class="line">        write(<span class="symbol">Word</span>),</div><div class="line">        nl,</div><div class="line">    loop(<span class="symbol">Word</span>).</div></pre></td></tr></table></figure>
<p>通过<strong>;/2</strong>谓词，可以改写为：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">loop:-</div><div class="line">    write(<span class="string">'Type end to end'</span>),</div><div class="line">    read(<span class="symbol">Word</span>),</div><div class="line">    write(<span class="string">'Input was '</span>),</div><div class="line">    write(<span class="symbol">Word</span>),</div><div class="line">    nl,</div><div class="line">    (<span class="symbol">Word</span>=end;loop).</div></pre></td></tr></table></figure></p>
<h3 id="3-使用repeat谓词"><a href="#3-使用repeat谓词" class="headerlink" title="3. 使用repeat谓词"></a>3. 使用repeat谓词</h3><p>这个谓词名称是典型的用词不当，repeat并不重复任何东西，它仅仅是在任何时候执行的时候都是success。那么当回溯到repeat的时候，因为它是成功的，那么就要继续从left-&gt;right的求值目标，直到后续的某个目标满足为止，例如：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">get_answer(<span class="symbol">Ans</span>):-</div><div class="line">write(<span class="string">'Enter answer to question'</span>),</div><div class="line">nl,</div><div class="line">repeat,</div><div class="line">write(<span class="string">'answer yes or no'</span>),</div><div class="line">read(<span class="symbol">Ans</span>),</div><div class="line">valid(<span class="symbol">Ans</span>),</div><div class="line">write(<span class="string">'Answer is '</span>),</div><div class="line">write(<span class="symbol">Ans</span>),</div><div class="line">nl.</div></pre></td></tr></table></figure>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">valid(yes). </div><div class="line">valid(no).</div></pre></td></tr></table></figure>
<p>这个程序检测输入，要求玩家必须输入yes或者no才算结束，在repeat到valid(Ans)之间，如果没有输入yes或者no，将循环多次，直到valid(Ans)目标被满足（也就是输入yes或者no）。回溯到repeat的时候，总是成功，那么就继续求值后续的目标write(‘answer yes or no’),read(Ans),repeat左边的部分永远不会被回溯到。</p>
<h3 id="4-fail谓词"><a href="#4-fail谓词" class="headerlink" title="4. fail谓词"></a>4. fail谓词</h3><p>fail谓词求值总是fail，因此强迫回溯开始，例如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dog(fido).</div><div class="line">dog(fred).</div><div class="line">dog(jonathan).</div><div class="line"></div><div class="line">all_dogs:-</div><div class="line">dog(X),</div><div class="line">write(X),</div><div class="line">write(&apos; is a dog&apos;),</div><div class="line">nl,</div><div class="line">fail.</div><div class="line"></div><div class="line">all_dogs.</div></pre></td></tr></table></figure>
<p>谓词all_dogs用于查询数据库中所有的dog，注意，最后的all_dogs.必须存在，不然all_dogs.在查找完所有的dog之后将总是fail。</p>
<hr>
<h1 id="第六章-预防回溯"><a href="#第六章-预防回溯" class="headerlink" title="第六章 预防回溯"></a>第六章 预防回溯</h1><h3 id="1-cut谓词"><a href="#1-cut谓词" class="headerlink" title="1. cut谓词"></a>1. cut谓词</h3><p>用于中止回溯，也可用!号表示。例如下面的例子是没有终止回溯的，    <strong>可以理解为switch语句没有break</strong>：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">classify(<span class="number">0</span>,zero).</div><div class="line">classify(<span class="symbol">N</span>,negative):- <span class="symbol">N</span>&lt;<span class="number">0.</span></div><div class="line">classify(<span class="symbol">N</span>,positive).</div></pre></td></tr></table></figure>
<p>用于检验某个数是正、负或者零。执行：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">?- classify(<span class="number">-4</span>,<span class="symbol">X</span>).</div><div class="line"><span class="symbol">X</span> = negative ;</div><div class="line"><span class="symbol">X</span> = positive</div></pre></td></tr></table></figure>
<p>由于不能中止回溯，当classify(N,negative):- N&lt;0.执行后，后续的也将执行，当然，你可以修改为：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">classify(<span class="number">0</span>,zero).</div><div class="line">classify(<span class="symbol">N</span>,negative):-<span class="symbol">N</span>&lt;<span class="number">0.</span></div><div class="line">classify(<span class="symbol">N</span>,positive):-<span class="symbol">N</span>&gt;<span class="number">0.</span></div></pre></td></tr></table></figure>
<p>如果用cut谓词更好，即在不是末句的规则后面加上感叹号“!”。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">classify(<span class="number">0</span>,zero):-!.</div><div class="line">classify(<span class="symbol">N</span>,negative):-<span class="symbol">N</span>&lt;<span class="number">0</span>,!.</div><div class="line">classify(<span class="symbol">N</span>,positive).</div></pre></td></tr></table></figure>
<p>尽管一些程序可以不通过cut谓词进行修改，但是有一些程序（特别是当一个谓词调用另一个谓词的时候）却是不得不借住cut谓词来中止回溯，才能实现正确的行为。<br>cut的另一个用途就是确定通常情况下以外的异常，与fail搭配使用，我们知道fail强迫回溯开始<br>例如有以下事实：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">bird(sparrow).</div><div class="line">bird(eagle).</div><div class="line">bird(duck).</div><div class="line">bird(crow).</div><div class="line">bird(ostrich).</div><div class="line">bird(puffin).</div><div class="line">bird(swan).</div><div class="line">bird(albatross).</div><div class="line">bird(starling).</div><div class="line">bird(owl).</div><div class="line">bird(kingfisher).</div><div class="line">bird(thrush).</div></pre></td></tr></table></figure>
<p>假设ostrich不能fly，我们的can_fly谓词可能实现为：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">can_fly(ostrich):-fail.</div><div class="line">can_fly(<span class="symbol">X</span>):-bird(<span class="symbol">X</span>).</div></pre></td></tr></table></figure>
<p>但是由于fail强制回溯，那么can_fly(ostrich).还是成功，怎么办呢？用cut：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">can_fly(ostrich):-!,fail.</div><div class="line">can_fly(<span class="symbol">X</span>):-bird(<span class="symbol">X</span>).</div></pre></td></tr></table></figure>
<p>cut中止了回溯。</p>
<hr>
<h1 id="第七章-改变Prolog数据库"><a href="#第七章-改变Prolog数据库" class="headerlink" title="第七章 改变Prolog数据库"></a>第七章 改变Prolog数据库</h1><h3 id="1-改变数据库：加入和删除语句"><a href="#1-改变数据库：加入和删除语句" class="headerlink" title="1. 改变数据库：加入和删除语句"></a>1. 改变数据库：加入和删除语句</h3><p>如果删除和加入语句仅仅靠consult和reconsult谓词是低效，因此Prolog提供了BIPs用于删除或者增加数据库中的语句。<strong>如果一个谓词可以被assertz, retract等BIPs修改，那么它必须声明是动态的。</strong>否则Prolog将报错。动态声明必须放在谓词声明的前面，最好放在整个程序的前面，声明方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dynamic(mypred/3).</div></pre></td></tr></table></figure></p>
<p>这就将mypred/3谓词声明为动态，可用BIPs进行增删了。</p>
<h3 id="1）增加语句"><a href="#1）增加语句" class="headerlink" title="1）增加语句"></a>1）增加语句</h3><p>通过谓词assertz/1和asserta/1，两者的区别在于：<strong>前者将语句加入相应谓词的后面，而后者将语句加入相应谓词的开始处。</strong>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">?- assertz(dog(fido)).</div><div class="line">?- assertz((go:-write(&apos;hello world&apos;),nl)).</div><div class="line">?- assertz(dog(X)).</div><div class="line">?- assertz((go(X):-write(&apos;hello&apos;), write(X),nl)).</div></pre></td></tr></table></figure></p>
<h3 id="2）删除语句"><a href="#2）删除语句" class="headerlink" title="2）删除语句"></a>2）删除语句</h3><p>也有两个谓词：retract/1和retractall/1，两者的区别在于：前者接受一个参数，并且是一条语句，删除数据库中第一条与该语 句匹配的语句；后者仅接受语句的head部分，用于删除所有的满足该head的语句。例如，假设数据库中有如下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dog(jim).</div><div class="line">dog(fido).</div><div class="line">dog(X).</div></pre></td></tr></table></figure></p>
<p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?- retract(dog(fido)).</div></pre></td></tr></table></figure></p>
<p>删除数据库中的第2条语句，执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?- retract(dog(X)).</div></pre></td></tr></table></figure></p>
<p>却是删除dog(jim).因为这是第一条与(dog(X)匹配的语句，而最后的dog(X).反而得到保留。<br>关于retractall的用法，用_代替参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">retractall(mypred(\_,\_,_)).  //删除所有的mypred/3谓词语句。</div><div class="line">retractall(parent(john,Y)).   //删除所有的第一个参数的john的parent/2语句。</div><div class="line">retractall(mypred).           //删除所有的mypred/0谓词。</div></pre></td></tr></table></figure></p>
<h3 id="2-维护事实库"><a href="#2-维护事实库" class="headerlink" title="2.维护事实库"></a>2.维护事实库</h3><p>利用文件读写IO谓词，和本章介绍的增删谓词，就用文本文件维护事实库了，具体例子不说了。</p>
<hr>
<h1 id="第八章-列表处理"><a href="#第八章-列表处理" class="headerlink" title="第八章 列表处理"></a>第八章 列表处理</h1><h3 id="1-列表的概念"><a href="#1-列表的概念" class="headerlink" title="1. 列表的概念"></a>1. 列表的概念</h3><p>list在Prolog中是以[]包括的，以,号隔开的term组成，例如[a,b,c,d]，空列表就是[]。了解过Erlang或者scheme的朋友，应该对列表很熟悉。Erlang中的列表与Prolog中的列表概念一脉相承。</p>
<h3 id="2-常用的BIPs"><a href="#2-常用的BIPs" class="headerlink" title="2. 常用的BIPs"></a>2. 常用的BIPs</h3><h4 id="1）member谓词"><a href="#1）member谓词" class="headerlink" title="1）member谓词"></a>1）member谓词</h4><p>判断元素是否在列表中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">?- member(a,[a,b,c]).</div><div class="line">yes</div><div class="line">?- member(mypred(a,b,c),[q,r,s,mypred(a,b,c),w]).</div><div class="line">yes</div></pre></td></tr></table></figure></p>
<p>如果member的第一个参数是未绑定的变量，那么该变量将从左到右依次绑定列表中的元素。</p>
<h4 id="2）length谓词"><a href="#2）length谓词" class="headerlink" title="2）length谓词"></a>2）length谓词</h4><p>确定列表长度，第2个参数如果是变量，将变量绑定为列表参数，如果是数字，就将该数字与长度比较，相等则success，否则fail。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">?- length([a,b,c,d],X).</div><div class="line">X = 4</div><div class="line">?- length([a,b,c],3).</div><div class="line">yes</div><div class="line">?- length([a,b,c],4).</div><div class="line">no</div></pre></td></tr></table></figure></p>
<h4 id="3）reverse谓词"><a href="#3）reverse谓词" class="headerlink" title="3）reverse谓词"></a>3）reverse谓词</h4><p>如果两个变量都是list，就判断是否互相倒序，如果一个是变量，一个是list，就将变量绑定为list的倒序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">?- reverse([1,2,3,4],L).</div><div class="line">L = [4,3,2,1]</div><div class="line">?- reverse(L,[1,2,3,4]).</div><div class="line">L = [4,3,2,1]</div><div class="line">?- reverse([1,2,3,4],[4,3,2,1]).</div><div class="line">yes</div></pre></td></tr></table></figure></p>
<h4 id="4）append谓词"><a href="#4）append谓词" class="headerlink" title="4）append谓词"></a>4）append谓词</h4><p>三个参数，如果前两个是list，第三个为变量，那么将变量绑定为两个list合并连接的列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">?- append([1,2,3,4],[5,6,7,8,9],L).</div><div class="line">L = [1,2,3,4,5,6,7,8,9]</div><div class="line">?- append([],[1,2,3],L).</div><div class="line">L = [1,2,3]</div></pre></td></tr></table></figure></p>
<p>如果前两个参数包括变量，第三个是列表，那么将回溯寻找所有可能的列表组合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">?- append(L1,L2,[1,2,3,4,5]).</div><div class="line">L1 = [] ,</div><div class="line">L2 = [1,2,3,4,5] ;</div><div class="line">L1 = [1] ,</div><div class="line">L2 = [2,3,4,5] ;</div><div class="line">L1 = [1,2] ,</div><div class="line">L2 = [3,4,5] ;</div><div class="line">L1 = [1,2,3] ,</div><div class="line">L2 = [4,5] ;</div><div class="line">L1 = [1,2,3,4] ,</div><div class="line">L2 = [5] ;</div><div class="line">L1 = [1,2,3,4,5] ,</div><div class="line">L2 =[] ;</div><div class="line">no</div></pre></td></tr></table></figure></p>
<h4 id="5）findall-3"><a href="#5）findall-3" class="headerlink" title="5）findall/3"></a>5）findall/3</h4><p>findall/3谓词比较有趣，有点类似select的概念，它有三个参数，第一个参数是一个变量或者带变量的表达式，用于确定想要find并且 collect的元素结构，第二个参数是一个goal，用于执行数据库中是否有匹配项，第三个参数是变量，用于绑定最后收集到的匹配的元素列表，例子：<br>假设我们已经如下事实：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">person(john,smith,45,london).</div><div class="line">person(mary,jones,28,edinburgh).</div><div class="line">person(michael,wilson,62,bristol).</div><div class="line">person(mark,smith,37,cardiff).</div><div class="line">person(henry,roberts,23,london).</div></pre></td></tr></table></figure></p>
<p>那么执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">findall(S,person(_,S,_,_),L).</div></pre></td></tr></table></figure></p>
<p>将返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">L = [smith,jones,wilson,smith,roberts]</div></pre></td></tr></table></figure></p>
<p>L收集了所有person的姓。如果执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?- findall([Forename,Surname],person(Forename,Surname,_,_),L).</div></pre></td></tr></table></figure></p>
<p>将返回所有person的姓名组成的列表的列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">L = [[john,smith],[mary,jones],[michael,wilson],[mark,smith],[henry,roberts]]</div></pre></td></tr></table></figure></p>
<p>这是个非常有用的谓词。</p>
<hr>
<h1 id="第九章-字符串处理"><a href="#第九章-字符串处理" class="headerlink" title="第九章 字符串处理"></a>第九章 字符串处理</h1><h3 id="1-单引号"><a href="#1-单引号" class="headerlink" title="1.单引号"></a>1.单引号</h3><p>单引号括起来的atom就是字符串，又一个Erlang沿用Prolog的典型，字符串本质上就是anscii码组成的列表，列表跟字符串可以互相转化，通过name/2谓词：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">?- name(&apos;Prolog Example&apos;,L).</div><div class="line">L = [80,114,111,108,111,103,32,69,120,97,109,112,108,101]</div><div class="line">?-name(A,[80,114,111,108,111,103,32,69,120,97,109,112,108,101]).</div><div class="line">A = &apos;Prolog Example&apos;</div></pre></td></tr></table></figure></p>
<h3 id="2-常用谓词"><a href="#2-常用谓词" class="headerlink" title="2. 常用谓词"></a>2. 常用谓词</h3><p>一般的Prolog系统其实都有字符串扩展谓词，这里提供基本的实现：</p>
<h4 id="1）连接字符串"><a href="#1）连接字符串" class="headerlink" title="1）连接字符串"></a>1）连接字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">join2(String1,String2,Newstring):-</div><div class="line">name(String1,L1),name(String2,L2),</div><div class="line">append(L1,L2,Newlist), </div><div class="line">name(Newstring,Newlist).</div></pre></td></tr></table></figure>
<p>转成列表，通过append连接成新的列表，再转成字符串。</p>
<h4 id="2）Trim谓词"><a href="#2）Trim谓词" class="headerlink" title="2）Trim谓词"></a>2）Trim谓词</h4><p>去除前后空格字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">trim([A|L],L1):-A=&lt;32,trim(L,L1).</div><div class="line">trim([A|L],[A|L]):-A&gt;32.</div><div class="line">trim2(L,L1):-</div><div class="line">reverse(L,Lrev),trim(Lrev,L2),reverse(L2,L1).</div><div class="line">trim3(L,L1):-trim(L,L2),trim2(L2,L1).</div><div class="line">trims(S,Snew):-name(S,L),trim3(L,L1),name(Snew,L1).</div></pre></td></tr></table></figure></p>
<p>真是麻烦呐，与join2是同样的套路。</p>
<h4 id="3）readline谓词："><a href="#3）readline谓词：" class="headerlink" title="3）readline谓词："></a>3）readline谓词：</h4><p>用于读入一行字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">readline(S):-</div><div class="line">readline1([],L),</div><div class="line">name(S,L),!.</div><div class="line"></div><div class="line">readline1(Oldlist,L):-</div><div class="line">get0(X),</div><div class="line">process(Oldlist,X,L).</div><div class="line"></div><div class="line">process(Oldlist,13,Oldlist).</div><div class="line"></div><div class="line">process(Oldlist,X,L):-</div><div class="line">append(Oldlist,[X],L1),</div><div class="line">readline1(L1,L).</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="第十章-高级特性"><a href="#第十章-高级特性" class="headerlink" title="第十章 高级特性"></a>第十章 高级特性</h1><h3 id="1-操作符的扩展，通过op-3谓词（略）"><a href="#1-操作符的扩展，通过op-3谓词（略）" class="headerlink" title="1. 操作符的扩展，通过op/3谓词（略）"></a>1. 操作符的扩展，通过op/3谓词（略）</h3><h3 id="2-term的处理"><a href="#2-term的处理" class="headerlink" title="2. term的处理"></a>2. term的处理</h3><p>比较有趣的=..操作符，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X=..[member,A,L].</div></pre></td></tr></table></figure></p>
<p>将X绑定为member(A,L).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X=..[colour,red].</div></pre></td></tr></table></figure></p>
<p>X绑定为color(red)，=..称为univ操作符（摘要操作符？),用于列表和term之间的相互转化，反过来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?- data(6,green,mypred(26,blue))=..L.</div></pre></td></tr></table></figure></p>
<p>L将绑定为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">L = [data,6,green,mypred(26,blue)]</div></pre></td></tr></table></figure></p>
<h3 id="3-call-1谓词"><a href="#3-call-1谓词" class="headerlink" title="3. call/1谓词"></a>3. call/1谓词</h3><p>接受一个call term参数，类似目标执行，例如：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call(write(<span class="string">'Hello world'</span>)).</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello worldyes</div></pre></td></tr></table></figure></p>
<p>可执行多个term:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">?- call(write(&apos;Hello world&apos;),nl).</div><div class="line">Hello world</div><div class="line">yes</div></pre></td></tr></table></figure></p>
<p>call跟=..联合调用：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">?- <span class="symbol">X</span>=..[write,<span class="string">'hello world'</span>],call(<span class="symbol">X</span>).</div><div class="line">hello worldX = write(<span class="string">'hello world'</span>)</div></pre></td></tr></table></figure></p>
<h3 id="4-functor-3谓词"><a href="#4-functor-3谓词" class="headerlink" title="4.functor/3谓词"></a>4.functor/3谓词</h3><p>当第一个参数是atom或者compound term或者某个绑定了类似值的变量，第二和第三个参数是未绑定变量，那么第二个参数变量将绑定为第一个参数的functor，第三个参数变量绑定为第一个参素的arity，举例子说明：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">?- functor(write(<span class="string">'hello world'</span>),<span class="symbol">A</span>,<span class="symbol">B</span>).</div><div class="line"><span class="symbol">A</span> = write ,</div><div class="line"><span class="symbol">B</span> = <span class="number">1</span></div><div class="line">?- functor(start,<span class="symbol">F</span>,<span class="symbol">A</span>).</div><div class="line"><span class="symbol">F</span> = start ,</div><div class="line"><span class="symbol">A</span> = <span class="number">0</span></div><div class="line">?- functor(a+b,<span class="symbol">F</span>,<span class="symbol">A</span>).</div><div class="line"><span class="symbol">F</span> = + ,</div><div class="line"><span class="symbol">A</span> = <span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>显然，atom的arity是0。反过来，如果第一个参数是未绑定变量，后两个参数已知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">?- functor(T,person,4).</div><div class="line">T = person(_42952,_42954,_42956,_42958)</div><div class="line">?- functor(T,start,0).</div><div class="line">T = start</div></pre></td></tr></table></figure></p>
<h3 id="5-arg-3谓词"><a href="#5-arg-3谓词" class="headerlink" title="5. arg/3谓词"></a>5. arg/3谓词</h3><p>根据第一个参数数值，取第二个参数term的相应位置的参数，例如：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">?- arg(<span class="number">3</span>,person(mary,jones,doctor,london),<span class="symbol">X</span>).</div><div class="line"><span class="symbol">X</span> = doctor</div></pre></td></tr></table></figure>
<p>X绑定为person(mary,jones,doctor,london)的第3个参数。</p>
<hr>
<h1 id="第十一章-输入流"><a href="#第十一章-输入流" class="headerlink" title="第十一章 输入流"></a>第十一章 输入流</h1><h3 id="1-读取csv格式文件"><a href="#1-读取csv格式文件" class="headerlink" title="1.读取csv格式文件"></a>1.读取csv格式文件</h3><p>创建一个csv格式文件如下，分割符号是分号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A1;A2</div><div class="line">B1;B2</div><div class="line">C1;C2</div></pre></td></tr></table></figure>
<p>创建一个prolog文件，设使用swi-prolog来执行，则文件如test.pl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">:- use_module(library(csv)).</div><div class="line">import:-</div><div class="line">csv_read_file(&apos;/Users/Leo/Documents/prolog/miniproject/example.csv&apos;, </div><div class="line">Data, </div><div class="line">[functor(fact), separator(0&apos;;)]),</div><div class="line">maplist(assert, Data).</div></pre></td></tr></table></figure>
<p>在运行时先载入该文件，然后输入以下代码：</p>
 <figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">?- import.</div><div class="line">true.</div><div class="line">?- setof([<span class="symbol">X</span>, <span class="symbol">Y</span>], fact(<span class="symbol">X</span>,<span class="symbol">Y</span>), <span class="symbol">Z</span>). </div><div class="line"><span class="symbol">Z</span> = [[<span class="string">'A1'</span>, <span class="string">'A2'</span>], [<span class="string">'B1'</span>, <span class="string">'B2'</span>], [<span class="string">'C1'</span>, <span class="string">'C2'</span>]].</div></pre></td></tr></table></figure>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>LearnProlog Now！<a href="http://www.learnprolognow.org/lpnpage.php?pageid=teaching" target="_blank" rel="external">http://www.learnprolognow.org/lpnpage.php?pageid=teaching</a><br>Prolog学习笔记：<a href="http://www.blogjava.net/killme2008/archive/2008/05/28/203662.html" target="_blank" rel="external">http://www.blogjava.net/killme2008/archive/2008/05/28/203662.html</a><br>Prolog和人工智能：<a href="http://hyry.dip.jp/tech/book/page.html/prolog/index.html" target="_blank" rel="external">http://hyry.dip.jp/tech/book/page.html/prolog/index.html</a></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><table>
<thead>
<tr>
<th>单词</th>
<th>英文释义</th>
<th>中文释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>BIPs</td>
<td>Built In Predicat</td>
<td>内建谓语，即Prolog自己保留的谓语，类似保留关键字</td>
</tr>
<tr>
<td>原子</td>
<td>Atom</td>
<td>所有的合法词语，可以作为事实也可以作为规则的名字</td>
</tr>
<tr>
<td>规则</td>
<td>Regular</td>
<td>储存事实，类似函数</td>
</tr>
</tbody>
</table>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Machine-Learning/">Machine Learning</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="2016/04/20/How-to-use-Prolog/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/14/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/16/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2017 leo
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>